# -*- coding: utf-8 -*-
"""Weighted_Round_Robbin_NetworkX_Influx_Outflux_Node

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MILhdyaAYarxZNK0mniF9Vp3PBEANlvg
"""

import numpy as np
# Calculate and print the mean and standard deviation of inflow and outflow
mean_inflow = np.mean(inflow)
std_inflow = np.std(inflow)
mean_outflow = np.mean(outflow)
std_outflow = np.std(outflow)

print(f"Inflow - Mean: {mean_inflow:.2f}, Standard Deviation: {std_inflow:.2f}")
print(f"Outflow - Mean: {mean_outflow:.2f}, Standard Deviation: {std_outflow:.2f}")

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.cm import ScalarMappable
from matplotlib.colors import Normalize

def weighted_round_robin_networkx(weights, num_requests):
    """Implements a weighted round-robin algorithm using NetworkX."""
    num_nodes = len(weights)
    G = nx.DiGraph()

    # Add nodes to the graph
    G.add_nodes_from(range(num_nodes))

    # Add edges with weights
    for i in range(num_nodes):
        # Assuming a simple connection for visualization, e.g., i to (i+1)%num_nodes
        G.add_edge(i, (i + 1) % num_nodes, weight=weights[i])

    node_inflow = np.zeros(num_nodes)
    node_outflow = np.zeros(num_nodes)
    current_node = 0
    current_weight = 0
    total_weight = sum(weights)

    for _ in range(num_requests):
        while True:
            current_node = (current_node + 1) % num_nodes
            if current_node == 0:
                current_weight -= total_weight
            current_weight += weights[current_node]
            if current_weight >= 0:
                break

        node_inflow[current_node] += 1
        # Assuming outflow is also 1 per request for simplicity
        node_outflow[current_node] += 1

    return G, node_inflow, node_outflow # Return the graph as well

# Define weights for 10 nodes
weights = [5, 4, 3, 2, 1, 1, 2, 3, 4, 5]
num_requests = 100  # Number of requests to simulate

# Run the weighted round-robin simulation using NetworkX
G, inflow, outflow = weighted_round_robin_networkx(weights, num_requests)

# Plot the results on the NetworkX graph
pos = nx.circular_layout(G)  # Use a circular layout for better visualization

fig, ax = plt.subplots(figsize=(12, 12)) # Create a figure and axes

# Draw nodes
nx.draw(G, pos, with_labels=True, node_size=1000, node_color='lightblue', font_size=12, font_color='black', ax=ax)

# Draw edges and get edge labels
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edges(G, pos, ax=ax, edge_color='gray', width=2)
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red', ax=ax)


plt.title('NetworkX Graph with Edge Weights as Labels')

plt.axis('off') # Hide axes
plt.show()