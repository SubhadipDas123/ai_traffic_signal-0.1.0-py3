# -*- coding: utf-8 -*-
"""Cost_Optimized_Hyperparameter_Tuning_Green_Light_Project_AI

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z6DOe-HV38D7YtthJvMbxoM51t31oKPS
"""



from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
import numpy as np

# Define features (X) and target (y)
X = df[['latency', 'time', 'congestion', 'vehicles_per_minute', 'road_width', 'num_alternate_routes', 'waiting_time', 'response_time']]
y = df['optimized_cost']

# Create and train the Multiple Linear Regression model
model = LinearRegression()
model.fit(X, y)

# Predict the optimized cost using the trained model
df['predicted_cost'] = model.predict(X)

# Display the DataFrame with both optimized and predicted costs
display(df[['optimized_cost', 'predicted_cost']])

# Plotting the predicted cost vs. one of the parameters (e.g., latency)
plt.figure(figsize=(10, 6))
plt.scatter(df['latency'], df['optimized_cost'], color='blue', label='Actual Optimized Cost')
# Sort data by latency to plot the best fit line clearly
df_sorted = df.sort_values('latency')
plt.plot(df_sorted['latency'], df_sorted['predicted_cost'], color='red', label='Predicted Optimized Cost (Best Fit Line)')
plt.xlabel('Latency')
plt.ylabel('Optimized Cost')
plt.title('Optimized Cost vs. Latency (Actual vs. Predicted)')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Generate a range of latency values from the minimum observed up to 100
# For other features, use the mean of the observed values as a representative value
min_latency = df['latency'].min()
forecast_latencies = np.linspace(min_latency, 100, 100).reshape(-1, 1)

# Create a DataFrame for forecasting, using mean values for other features
forecast_data = pd.DataFrame(forecast_latencies, columns=['latency'])
mean_values = df.drop(['latency', 'optimized_cost', 'predicted_cost'], axis=1).mean()
for col in mean_values.index:
    forecast_data[col] = mean_values[col]

# Ensure the order of columns in forecast_data matches the order in X used for training
forecast_data = forecast_data[X.columns]

# Predict the optimized cost for the forecast latency values
forecast_predictions = model.predict(forecast_data)

# Plot the original data and the forecasted predictions
plt.figure(figsize=(10, 6))
plt.scatter(df['latency'], df['optimized_cost'], color='blue', label='Actual Optimized Cost')
plt.scatter(df['latency'], df['predicted_cost'], color='red', label='Predicted Optimized Cost (Training Data)')
plt.plot(forecast_data['latency'], forecast_predictions, color='green', linestyle='--', label='Forecasted Optimized Cost (up to 100ms Latency)')

plt.xlabel('Latency')
plt.ylabel('Optimized Cost')
plt.title('Optimized Cost vs. Latency (Actual, Predicted, and Forecast)')
plt.legend()
plt.grid(True)
plt.show()

# Display the coefficients and intercept of the model
print("Model Coefficients:")
for feature, coef in zip(X.columns, model.coef_):
    print(f"{feature}: {coef}")

print(f"\nModel Intercept: {model.intercept_}")

import matplotlib.pyplot as plt

# Plotting the predicted cost vs. congestion
plt.figure(figsize=(10, 6))
plt.scatter(df['congestion'], df['predicted_cost'], color='green')
plt.xlabel('Congestion')
plt.ylabel('Predicted Optimized Cost')
plt.title('Predicted Optimized Cost vs. Congestion')
plt.grid(True)
plt.show()

# Plotting the predicted cost vs. latency
plt.figure(figsize=(10, 6))
plt.scatter(df['latency'], df['predicted_cost'], color='purple')
plt.xlabel('Latency')
plt.ylabel('Predicted Optimized Cost')
plt.title('Predicted Optimized Cost vs. Latency')
plt.grid(True)
plt.show()

import pandas as pd
import numpy as np

def optimize_cost(latency, time, congestion, vehicles_per_minute, road_width, num_alternate_routes, waiting_time, response_time):
    """
    Placeholder function for cost optimization based on traffic parameters.
    This function needs to be replaced with actual optimization logic.
    For demonstration, it returns a dummy cost value.
    """
    # In a real scenario, this would contain complex optimization logic
    # involving all the input parameters.
    # This is a simplified example to show how the parameters can be used.
    cost = (latency * 0.1 + time * 0.05 + congestion * 0.3 +
            vehicles_per_minute * 0.2 + road_width * -0.05 +
            num_alternate_routes * -0.1 + waiting_time * 0.15 +
            response_time * 0.05)
    return max(0, cost) # Ensure cost is non-negative

# Create a sample DataFrame with the specified parameters
data = {
    'latency': np.random.rand(10) * 100, # milliseconds
    'time': np.random.rand(10) * 24,     # hours of the day
    'congestion': np.random.rand(10),    # scale of 0 to 1
    'vehicles_per_minute': np.random.rand(10) * 50, # vehicles
    'road_width': np.random.rand(10) * 20,  # meters
    'num_alternate_routes': np.random.randint(0, 5, 10), # number of routes
    'waiting_time': np.random.rand(10) * 30, # minutes
    'response_time': np.random.rand(10) * 10 # seconds
}

df = pd.DataFrame(data) 

# Apply the optimization function to each row to get a 'cost' column
df['optimized_cost'] = df.apply(lambda row: optimize_cost(
    row['latency'],
    row['time'],
    row['congestion'],
    row['vehicles_per_minute'],
    row['road_width'],
    row['num_alternate_routes'],
    row['waiting_time'],
    row['response_time']
), axis=1)

# Display the DataFrame with the calculated costs
display(df)